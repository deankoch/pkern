% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pkern_model.R
\name{pkern_LL}
\alias{pkern_LL}
\title{Compute likelihood function value for covariance parameters \code{pars} given data \code{g_obs}}
\usage{
pkern_LL(
  pars,
  g_obs,
  X = 0,
  method = "chol",
  fac = NULL,
  quiet = TRUE,
  more = FALSE
)
}
\arguments{
\item{pars}{list of form returned by \code{pkern_pars} (with entries 'y', 'x', 'eps', 'psill')}

\item{g_obs}{list of form returned by \code{pkern_grid} (with entries 'gdim', 'gres', 'gval')}

\item{X}{numeric, vector, matrix, or NA, a fixed mean value, or matrix of linear predictors}

\item{method}{character, the factorization to use: 'chol' (default) or 'eigen'}

\item{fac}{matrix or list, (optional) pre-computed covariance factorization}

\item{quiet}{logical indicating to suppress console output}

\item{more}{logical, indicates to return list with likelihood components}
}
\value{
numeric, the likelihood of \code{pars} given \code{g_obs}
}
\description{
Returns the log-likelihood of model parameter list \code{pars}, given data grid \code{g_obs}.
This is equal to \code{-log( 2 * pi ) - ( 1/2 ) * ( log_det + quad_form )}, where \code{log_det}
is the log-determinant of covariance matrix V, and \code{quad_form} is z^T V^{-1} z, with
z equal to the observed data vector minus the model mean.
}
\details{
If the model has a known trend (mean) vector, supply it in \code{X}. A spatially constant mean
can be supplied as (length-1) numeric. If \code{X} is a matrix, it is interpreted as a data
matrix of predictors for the non-NA values in \code{g_obs}; the function uses GLS to estimate
the mean. If \code{X=NA} it estimates a spatially constant mean.

When \code{more=TRUE}, the function returns a list containing a count of the number of
observations, the likelihood function value, and its two major components; the
log-determinant \code{log_det}, and the quadratic form \code{quad_form}.

\code{method} specifies how to factorize V, either using the Cholesky factor ('chol')
or eigen-decomposition ('eigen'). A pre-computed factorization \code{fac} can be supplied by
calling first \code{pkern_var} with the same \code{method}.
}
\examples{
# set up example grid, data, covariance parameters
gdim = c(25, 12)
n_obs = prod(gdim)
g_obs = pkern_grid(gdim)
pars = modifyList(pkern_pars(g_obs, 'gau') , list(psill=2))

# generate some covariates and data
n_betas = 3
betas = rnorm(n_betas)
X_all = cbind(1, matrix(rnorm(n_obs*(n_betas-1)), n_obs))
g_obs$gval = as.vector( rnorm(n_obs) + (X_all \%*\% betas) )

# two methods for likelihood
LL_chol = pkern_LL(pars, g_obs, method='chol')
LL_eigen = pkern_LL(pars, g_obs, method='eigen')

# (don't pass the intercept column in X)
X = X_all[,-1]
LL_X_chol = pkern_LL(pars, g_obs, X=X)
LL_X_eigen = pkern_LL(pars, g_obs, method='eigen', X=X)

# compare to working directly with matrix inverse
V = pkern_var(g_obs, pars, sep=FALSE)
z = g_obs$gval
g_trans = V |> chol() |> chol2inv() |> crossprod(z)
quad_form = as.numeric( t(z) \%*\% g_trans )
log_det = determinant(V)$modulus |> as.numeric()
LL_naive = -log(2*pi) - ( ( log_det + quad_form ) / 2 )

# relative errors
abs( LL_naive - LL_chol ) / max(LL_naive, LL_chol)
abs( LL_naive - LL_eigen ) / max(LL_naive, LL_eigen)

# repeat with covariates
V_inv = V |> chol() |> chol2inv()
X_tilde_inv = crossprod(crossprod(V_inv, X_all), X_all) |> chol() |> chol2inv()
betas_gls = X_tilde_inv \%*\% crossprod(X_all, g_trans)
z_gls = z - (X_all \%*\% betas_gls)
z_gls_trans = V_inv |> crossprod(z_gls)
quad_form = as.numeric( t(z_gls) \%*\% z_gls_trans )
LL_naive = -log(2*pi) - ( ( log_det + quad_form ) / 2 )
abs( LL_naive - LL_X_chol ) / max(LL_naive, LL_X_chol)
abs( LL_naive - LL_X_eigen ) / max(LL_naive, LL_X_eigen)

# return components of likelihood with more=TRUE
LL_result = pkern_LL(pars, g_obs, X=X, more=TRUE)
LL_result$LL - LL_X_chol
LL_result$q - quad_form
LL_result$d - log_det
LL_result$n - n_obs

# find max profile likelihood for psill with eps replaced by eps*psill and all other pars fixed
psill_best = LL_result$q / LL_result$n
pars_opt = pars |> modifyList(list(psill=psill_best, eps=pars$eps*psill_best))
anything_else = abs(rnorm(1))
pars_other = pars |> modifyList(list(psill=anything_else, eps=pars$eps*anything_else))
pkern_LL(pars_opt, g_obs, X=X) > pkern_LL(pars_other, g_obs, X=X)

}
