% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pkern_model.R
\name{pkern_LL}
\alias{pkern_LL}
\title{Compute likelihood function value for covariance parameters \code{pars} given data \code{g_obs}}
\usage{
pkern_LL(
  pars,
  g_obs,
  X = 0,
  method = "chol",
  fac = NULL,
  quiet = TRUE,
  more = FALSE
)
}
\arguments{
\item{pars}{list of form returned by \code{pkern_pars} (with entries 'y', 'x', 'eps', 'psill')}

\item{g_obs}{list of form returned by \code{pkern_grid} (with entries 'gdim', 'gres', 'gval')}

\item{X}{numeric, vector, matrix, or NA, a fixed mean value, or matrix of linear predictors}

\item{method}{character, the factorization to use: 'chol' (default) or 'eigen'}

\item{fac}{matrix or list, (optional) pre-computed covariance factorization}

\item{quiet}{logical indicating to suppress console output}

\item{more}{logical, indicates to return list with likelihood components}
}
\value{
numeric, the likelihood of \code{pars} given \code{g_obs}
}
\description{
Returns the log-likelihood of model parameter list \code{pars}, given data grid \code{g_obs}.
This is equal to \code{-log( 2 * pi ) - ( 1/2 ) * ( log_det + quad_form )}, where \code{log_det}
is the log-determinant of covariance matrix V, and \code{quad_form} is z^T V^{-1} z, with
z equal to the observed data vector minus the model mean.
}
\details{
If the model has a known trend (mean) vector, supply it in \code{X}. A spatially constant mean
can be supplied as (length-1) numeric. If \code{X} is a matrix, it is interpreted as a data
matrix of predictors for the non-NA values in \code{g_obs}; the function uses GLS to estimate
the mean. If \code{X=NA} it estimates a spatially constant mean.

When \code{more=TRUE}, the function returns a list containing a count of the number of
observations, the likelihood function value, and its two major components; the
log-determinant \code{log_det}, and the quadratic form \code{quad_form}.

\code{method} specifies how to factorize V, either using the Cholesky factor ('chol')
or eigen-decomposition ('eigen'). A pre-computed factorization \code{fac} can be supplied by
calling first \code{pkern_var} with the same \code{method}.
}
\examples{
# set up example grid, covariance parameters
gdim = c(25, 12)
n = prod(gdim)
g_obs = pkern_grid(gdim)
pars = modifyList(pkern_pars(g_obs, 'gau'), list(psill=0.7, eps=5e-2))

# generate some covariates and complete data
n_betas = 3
betas = rnorm(n_betas)
X_all = cbind(1, matrix(rnorm(n*(n_betas-1)), n))
g_obs[['gval']] = as.vector( pkern_sim(g_obs) + (X_all \%*\% betas) )
z = g_obs[['gval']]

# two methods for likelihood
LL_chol = pkern_LL(pars, g_obs, method='chol')
LL_eigen = pkern_LL(pars, g_obs, method='eigen')

# compare to working directly with matrix inverse
V = pkern_var(g_obs, pars, method='none', sep=FALSE)
V_inv = chol2inv(chol(V))
g_trans = crossprod(V_inv, z)
quad_form = as.numeric( t(z) \%*\% g_trans )
log_det = as.numeric( determinant(V, logarithm=TRUE) )[1]
LL_naive = (-1/2) * ( n * log( 2 * pi ) + log_det + quad_form )

# relative errors
abs( LL_naive - LL_chol ) / max(LL_naive, LL_chol)
abs( LL_naive - LL_eigen ) / max(LL_naive, LL_eigen)


# repeat with most data missing
n_obs = 50
idx_obs = sort(sample.int(n, n_obs))
z_obs = g_obs$gval[idx_obs]
g_miss = modifyList(g_obs, list(gval=rep(NA, n)))
g_miss[['gval']][idx_obs] = z_obs
LL_chol = pkern_LL(pars, g_miss, method='chol')
LL_eigen = pkern_LL(pars, g_miss, method='eigen')

# working with matrix inverse
V = pkern_var(g_miss, pars, method='none')
z_mat = matrix(z_obs, ncol=1)
V_inv = chol2inv(chol(V))
g_trans = (V_inv \%*\% z_mat)
quad_form = t(z_mat) \%*\% g_trans
log_det = as.numeric( determinant(V, logarithm=TRUE) )[1]
LL_naive = (-1/2) * ( n_obs * log( 2 * pi ) + log_det + quad_form )
abs( LL_naive - LL_chol ) / max(LL_naive, LL_chol)
abs( LL_naive - LL_eigen ) / max(LL_naive, LL_eigen)

# copy covariates (don't pass the intercept column in X)
X = X_all[idx_obs, -1]

# use GLS to de-trend, with and without covariatea
g_detrend = g_detrend_X = g_miss
g_detrend[['gval']][idx_obs] = z_obs - pkern_GLS(g_miss, pars)
g_detrend_X[['gval']][idx_obs] = z_obs - pkern_GLS(g_miss, pars, X, out='z')

# pass X (or NA) to pkern_LL to do this automatically
LL_detrend = pkern_LL(pars, g_detrend)
LL_detrend_X = pkern_LL(pars, g_detrend_X)
LL_detrend - pkern_LL(pars, g_miss, X=NA)
LL_detrend_X - pkern_LL(pars, g_miss, X=X)

# equivalent sparse input specification
idx_grid = match(seq(n), idx_obs)
g_sparse = modifyList(g_obs, list(gval=matrix(z_obs, ncol=1), idx_grid=idx_grid))
LL_chol - pkern_LL(pars, g_sparse)
LL_eigen - pkern_LL(pars, g_sparse)
LL_detrend - pkern_LL(pars, g_sparse, X=NA)
LL_detrend_X - pkern_LL(pars, g_sparse, X=X)


# repeat with complete data

# (don't pass the intercept column in X)
X = X_all[,-1]
LL_X_chol = pkern_LL(pars, g_obs, X=X)
LL_X_eigen = pkern_LL(pars, g_obs, method='eigen', X=X)
z_obs = g_obs$gval[!is.na(g_obs$gval)]
z_mat = matrix(z_obs, ncol=1)
V = pkern_var(g_obs, pars, sep=FALSE)
V_inv = chol2inv(chol(V))
X_tilde_inv = crossprod(crossprod(V_inv, X_all), X_all) |> chol() |> chol2inv()
g_trans = (V_inv \%*\% z_mat)
betas_gls = X_tilde_inv \%*\% crossprod(X_all, g_trans)
z_gls = z_mat - (X_all \%*\% betas_gls)
z_gls_trans = crossprod(V_inv, z_gls)
quad_form = as.numeric( t(z_gls) \%*\% z_gls_trans )
log_det = as.numeric( determinant(V, logarithm=TRUE) )[1]
LL_naive = (-1/2) * ( n * log( 2 * pi ) + log_det + quad_form )
abs( LL_naive - LL_X_chol ) / max(LL_naive, LL_X_chol)
abs( LL_naive - LL_X_eigen ) / max(LL_naive, LL_X_eigen)

# return components of likelihood with more=TRUE
LL_result = pkern_LL(pars, g_obs, X=X, more=TRUE)
LL_result$LL - LL_X_chol
LL_result$q - quad_form
LL_result$d - log_det
LL_result$n - n


}
