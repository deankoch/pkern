% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pkern_snap.R
\name{pkern_snap}
\alias{pkern_snap}
\title{Snap an irregular set of 2d points to the nearest regular subgrid}
\usage{
pkern_snap(gyx, pts, sep = NULL, distinct = FALSE, quiet = FALSE)
}
\arguments{
\item{gyx}{list of two vectors, the y and x grid line coordinates (ascending order)}

\item{pts}{list of two vectors, the y and x point coordinates}

\item{sep}{integer vector, where \code{sep-1} is the number of grid lines between each subgrid line}

\item{distinct}{logical, indicating to snap no more than one input point to each grid point}

\item{quiet}{logical indicating to suppress console messages}
}
\value{
a large list containing info about grid and subgrid (see details)
}
\description{
Snaps points to a subgrid, either by calling \code{pkern_snap_1d} twice, or by using the
Hungarian algorithm to solve the grid assignment problem.
}
\details{
\code{gyx} can be a RasterLayer, a list of y and x coordinates, or a list containing the
coordinates (in element \code{gyx$gyx}) as returned by \code{pkern_fromRaster}.

\code{sep} is a positive integer (or vector of two) specifying the factor(s) by which to
multiply the outer grid resolution to get the subgrid. Equivalently, this is the
separation distance between adjacent subgrid lines, given in terms of the number of
outer grid lines - eg. if \code{sep = c(1,1)} then all outer grid lines are included in the
subgrid; And if \code{sep=c(2,1)}, then only every second y grid line is included. \code{pkern}
includes a helper function for choosing \code{sep} automatically. This is done by default
when \code{sep} is not specified.

By default (\code{distinct=TRUE}) the function uses the Hungarian algorithm to find
the mapping which minimizes the total sum of squared snapping distances, under the
constraint that no more than one input point is assigned to each subgrid point.
When \code{distinct=FALSE} the function simply maps each point to the nearest x and y grid
lines separately (minimizing total Manhattan distance)

The output list contains info about the configuration of the grid and subgrid, along
with several indexing vectors for mapping between the input points and the grid points -

\code{gdim}, the input grid dimensions (ny, nx)
\code{gres}, the input grid resolution (copied from \code{gyx} or set to \code{c(1,1)})
\code{gyx}, the input grid line coordinates (copied from input \code{gyx})
\code{sep}, the selected subgrid spacing
\code{pmap}, list of integer vectors, dimension-wise mapping from \code{pts} to \code{gyx}
\code{gli}, list of integer vectors, dimension-wise grid line numbers forming the subgrid
\code{pvec}, integer vector mapping from \code{pts} to full grid, in column-vectorized order
\code{pdist}, numeric vector of Euclidean snapping distances
\code{sg}, list with information about the subgrid:
\code{gdim}, the subgrid dimensions (ny, nx)
\code{gyx}, the subgrid line coordinates (subsets of \code{gyx} in parent list)
\code{gres}, the subgrid resolution (equal to \code{sep * gres} in parent list)
\code{pvec}, integer vector mapping from \code{pts} to subgrid, in column-vectorized order
\code{ipvec}, integer vector, the inverse of the above mapping (with NAs for unmapped grid points)
}
\examples{
# define a grid of coordinates and add jitter to a subgrid
gdim = c(y=100, x=100)
gres = c(y=2, x=2)
sep = c(y=5, x=8)
gyx = Map(\(p, r) seq(1, p, by=r), p=gdim, r=gres)
ng = prod(sapply(gyx, length))
pts = Map(\(p, r) seq(1, p, by=r), p=gdim, r=sep*gres) |>
expand.grid() + stats::rnorm(2*ng, 0 , 3)

# plot grid and the point set generated from it
pkern_snap_plot(gyx, pts)

# compute score for a range of y separation values, given sep_x=18
sep_test = seq_along(gyx[['y']])
g = list(gyx=gyx, gdim=gdim, gres=gres)
pts_list = pts |> as.data.frame() |> as.list()
test_score = sapply(sep_test, \(y) pkern_snap_score_2d(sep=c(y=y, x=8), g, pts_list))
plot(sep_test, test_score, pch=16, cex=0.5)
lines(sep_test, test_score)

# estimate sep based on this score and the distance distribution among points
sep = pkern_estimate_sep(g, pts)
print(sep)

# plot resulting snapping map
snap = pkern_snap(g, pts, sep)
pkern_snap_plot(snap, pts)

# snap to grid lines, eliminate duplicates
snap.distinct = pkern_snap(g, pts, distinct=TRUE)
pkern_snap_plot(snap.distinct, pts)

# another example with and more jitter
pts = expand.grid(gyx) + stats::rnorm(2*ng, sd=3)
pts = pts[sample(ng, 50),]
pkern_snap_plot(g, pts)
snap = pkern_snap(g, pts, sep=3)
pkern_snap_plot(snap, pts)

# call again with smaller sep
snap.distinct = pkern_snap(g, pts, sep=2)
pkern_snap_plot(snap.distinct, pts)

# call again with sep determined automatically
snap.distinct = pkern_snap(g, pts)
pkern_snap_plot(snap.distinct, pts)
}
