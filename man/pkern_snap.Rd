% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pkern_grid.R
\name{pkern_snap}
\alias{pkern_snap}
\title{Snap a set of points to a grid}
\usage{
pkern_snap(from, g = NULL, crop_from = FALSE, crop_g = FALSE, quiet = FALSE)
}
\arguments{
\item{from}{matrix, data frame, or points object from \code{sp} or \code{sf}, the source points}

\item{g}{any grid object accepted or returned by \code{pkern_grid}, the destination grid}

\item{crop_from}{logical, indicating to omit points not overlying \code{g}.}

\item{crop_g}{logical, indicating to trim \code{g} to the extent of \code{from}.}
}
\value{
list of form returned by \code{pkern_grid}, defining a grid containing the snapped
points. These are assigned the corresponding data value in \code{from}, or if  \code{from} has no
data, an integer mapping to the points in \code{from}. Un-mapped grid points are set to NA.
}
\description{
Maps the input points in \code{from} to the closest grid points in the extension of \code{g}
covering the bounding box of \code{from} (ie. the lattice of which \code{g} is a sub-grid).
In cases of duplicate mappings, the function returns the first matches only.
}
\details{
\code{from} can be a geometry collection from packages \code{sf} or \code{sp}, or a matrix or list
of y and x coordinates. When \code{from} is a matrix, its first two columns should be the
y and x coordinates (in that order), and the (optional) third column should be the
data. When \code{from} is a list, the function expects (two or three) vectors of equal
length, ordered as above.

When \code{from} is a geometry collection with a coordinates reference system (CRS) string,
points are first transformed to the CRS of \code{g}. If one or both of \code{from} and \code{g} are
missing a CRS definition, the function assumes the same one is shared in both.

\code{g} can be a raster geometry object (such as SpatRaster), in which case the function
behaves like \code{terra::rasterize}. It can also be a matrix (supplying dimensions) or a
list containing either \code{gdim} or\code{gres}, from which an appropriately spaced set of grid
lines is derived, centered under the bounding box of the points.

\code{crop_from} and \code{crop_g} control the extent of the output grid. If both are \code{FALSE}
(the default) the function returns the smallest regular grid containing both \code{g}
and the snapped \code{from} points. If \code{crop_from=TRUE} and \code{crop_g=FALSE} the output
grid will match \code{g} exactly. If \code{crop_from=FALSE} and \code{crop_g=TRUE} the output
grid will include all snapped points, and possibly omit some or all of \code{g}. And if
both are \code{TRUE}, the output grid encloses the intersection of the points with the
bounding box of \code{g}.
}
\examples{

# functions to scale arbitrary inverval to (1, 2,... 100) and make color palettes
num_to_cent = function(x) 1L + floor(99*( x-min(x) ) / diff(range(x)))
my_pal = function(x) hcl.colors(x, 'Spectral', rev=T)
my_col = function(x) my_pal(1e2)[ num_to_cent(x) ]

# create a grid object
gdim = c(40, 30)
g = pkern_grid(list(gdim=gdim, gres=1.1))

# randomly position points within bounding box of g
n_pts = 10
from = lapply(g$gyx, function(yx) runif(n_pts, min(yx), max(yx)) )

# translate away from g (no overlap is required)
from[['y']] = from[['y']] + 5
from[['x']] = from[['x']] + 15

# add example data values and plot
from[['z']] = rnorm(length(from[['y']]))
pkern_plot(g, reset=FALSE)
graphics::points(from[c('x', 'y')], pch=16, col=my_col(from[['z']]))
graphics::points(from[c('x', 'y')])

# snap only the points overlying the input grid
g_snap = pkern_snap(from, g, crop_from=TRUE)
pkern_plot(g_snap, col_grid='black', reset=FALSE, leg=FALSE)
graphics::points(from[c('x', 'y')], pch=16, col=my_col(from[['z']]))
graphics::points(from[c('x', 'y')])

# snap points with  and plot (default settings)
g_snap = pkern_snap(from, g, crop_from=FALSE, crop_g=FALSE)
pkern_plot(g_snap, col_grid='black', reset=FALSE)
graphics::points(from[c('x', 'y')], pch=16, col=my_col(from[['z']]))
graphics::points(from[c('x', 'y')])

# find smallest subgrid enclosing all snapped grid points
g_snap = pkern_snap(from, g, crop_g=TRUE)
pkern_plot(g_snap, col_grid='black', reset=FALSE)
graphics::points(from[c('x', 'y')], pch=16, col=my_col(from[['z']]))
graphics::points(from[c('x', 'y')])

# create a new grid of different resolution enclosing all input points
g_snap = pkern_snap(from, g=list(gres=c(0.5, 0.5)))
pkern_plot(g_snap, reset=FALSE, col_grid='black')
graphics::points(from[c('x', 'y')], pch=16, col=my_col(from[['z']]))
graphics::points(from[c('x', 'y')])

if( requireNamespace('sf') ) {

# a different example, snapping mis-aligned subgrid
g_pts = pkern_grid(list(gdim=c(15, 8), gres=1.7), vals=FALSE)
g_pts[['gyx']][['y']] = g_pts[['gyx']][['y']] + 5
g_pts[['gyx']][['x']] = g_pts[['gyx']][['x']] + 5
n_pts = prod(g_pts$gdim)
from = pkern_coords(g_pts, out='list')

# convert to sf
eg_sfc = sf::st_geometry(pkern_coords(g_pts, out='sf'))
pkern_plot(g, reset=FALSE)
plot(eg_sfc, add=TRUE)

# generate example data and plot
eg_sf = sf::st_sf(data.frame(z=rnorm(n_pts)), geometry=eg_sfc)
pkern_plot(g, reset=FALSE)
plot(eg_sf, pch=16, add=TRUE, pal=my_pal)
plot(eg_sfc, add=TRUE)

# snap points
g_snap = pkern_snap(from=eg_sf, g)
pkern_plot(g_snap, reset=FALSE, col_grid='black')
plot(eg_sf, pch=16, add=TRUE, pal=my_pal)
plot(eg_sfc, add=TRUE)

# snapping points without data produces the mapping (non-NA values index "from")
g_snap = pkern_snap(from=eg_sfc, g)
pkern_plot(g_snap, ij=TRUE, reset=FALSE, col_grid='black')
plot(eg_sfc, add=TRUE)

# with crop_g=TRUE)
g_snap = pkern_snap(from=eg_sfc, g, crop_g=TRUE)
pkern_plot(g_snap, reset=FALSE, col_grid='black')
plot(eg_sfc, add=TRUE)

# test with sp class
eg_sp = as(eg_sf,'Spatial')
g_snap = pkern_snap(from=eg_sp, g)
pkern_plot(g_snap, reset=FALSE, col_grid='black')
plot(eg_sf, pch=16, add=TRUE, pal=my_pal)
plot(eg_sfc, add=TRUE)

}

}
