% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pkern_indexing.R
\name{pkern_idx_sg}
\alias{pkern_idx_sg}
\title{Find column-vectorized index of a subgrid}
\usage{
pkern_idx_sg(gdim, ij = NULL, nosort = FALSE)
}
\arguments{
\item{gdim}{c(ni, nj), the number rows and columns in the full grid}

\item{ij}{list containing vectors "i" and "j", the subgrid rows and columns}

\item{nosort}{logical, skips sorting the input vectors in \code{ij}}
}
\value{
integer vector, with length equal to the product of the lengths of "i" and "j"
}
\description{
Returns the column-vectorized index of a subgrid with respect to the full grid
of size \code{gdim}, based on the supplied grid line numbers \code{ij}. The returned vector
maps to points in the full grid (in column-vectorized order) lying at the
intersections of \code{ij} (a subset of \code{seq(n)}, where \code{n=prod(gdim)}).
}
\details{
NA \code{ij[1]} indicates to use all rows and NA \code{ij[2]} indicates to use all columns.
If \verb{j = c(j1, j2, ..., in)} and \code{i = c(i1, i2, ...im)} the function returns:

(j1, i1), (j1, i2), ... (j1, im), (j2, i1), (j2, i2), ..., (j3, i1), ... (jm, in).

By default, the function sorts the grid lines in \code{ij} into ascending order, so that
the output is in column-vectorized order. \code{nosort=TRUE} skips the sorting, allowing
alternative output orders.
}
\examples{

gdim = c(5,6)
pkern_idx_sg(gdim)
ij = list(i = c(2,4), j = c(1,3,5))
pkern_idx_sg(gdim, ij)
}
