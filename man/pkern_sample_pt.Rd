% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pkern_sample.R
\name{pkern_sample_pt}
\alias{pkern_sample_pt}
\title{Sub-grid point sampler for grid data}
\usage{
pkern_sample_pt(g, n = 100, lag_max = 0, interval = 1L, over = FALSE)
}
\arguments{
\item{g}{any grid object accepted or returned by \code{pkern_grid}}

\item{n}{integer > 0, the maximum number of center points to sample}

\item{lag_max}{integer, Moore neighborhood radius (ie the maximum queen's distance)}

\item{interval}{integer > 0, the down-scaling factor for sub-grids of \code{g}}

\item{over}{logical, indicates to allow overlapping sub-grids (when they can be avoided)}
}
\value{
If \code{lag_max=0} (the default), the function returns the sample indices as a
length-\code{n} integer vector. If \code{lag_max} is positive, the function returns a list of
\code{n+1} indexing vectors; the first locates the \code{n} sub-grid center points, and the
following \code{n} vectors locate the points in each sub-grid (including the center points
itself)
}
\description{
Sample \code{n} locations from the non-NA points in the input grid \code{g}, optionally using
them as centers to place \code{n} sub-grids of the specified size and resolution.
}
\details{
The function draws a sample of \code{n} locations (uniformly at random) from the non-NA
points in the input grid \code{g}, and returns their vector index. If there are fewer
than \code{n} locations available, they are all returned.

When \code{lag_max > 1}, the function also identifies a regular sub-grid of the Moore
neighbourhood of (integer) radius \code{lag_max} around each of the sample points, with
\code{interval-1} grid lines separating each sub-grid line. \code{interval} is the factor by
which the resolution of the sub-grid is scaled to get the original grid resolution;
It must evenly divide \code{lag_max}.

For a given \code{interval}, the grid \code{g} can be partitioned into \code{interval^2} distinct
non-overlapping sub-grids. When \code{over=FALSE} (the default), the function apportions
its \code{n} point samples as evenly as possible among these disjoint subsets. This ensures
that if \code{n} is less than or equal to \code{interval^2}, and there are no NAs, there can be
no repetition (or "over"lap) of points in the returned sub-grids.
}
\examples{
# define a grid
gdim = c(100, 100)
ng = prod(gdim)

# get an ordinary random sample with default settings
idx_sample = pkern_sample_pt(g=gdim)
pkern_plot(seq(ng) \%in\% idx_sample, gdim)

# reduce or increase number of center points from default 100
idx_sample = pkern_sample_pt(gdim, n=10)
pkern_plot(seq(ng) \%in\% idx_sample, gdim)

# sampled from Moore neighbourhoods of radius 6
n = 10
idx_sample = pkern_sample_pt(gdim, n=n, lag_max=6L)
pkern_plot(seq(ng) \%in\% unlist(idx_sample), gdim, col_grid='white')

# plot each list element a different color
group_sample = rep(0L, prod(gdim))
for(i in seq(1 + n)[-1]) group_sample[ idx_sample[[i]] ] = i-1L
pkern_plot(group_sample, gdim, breaks=c('not sampled', seq(n)), zlab='sub-grid')

# When interval > 1, the function attempts to avoid overlap whenever possible
interval = 2
n = interval^2 # to get disjoint results n must be less than or equal to interval^2
lag_max = 10 * interval # vary to get larger/smaller subsets. max allowable: min(gdim)/2
idx_sample = pkern_sample_pt(gdim, n=n, interval=interval, lag_max=lag_max)
idx_overlap = rowSums( sapply(idx_sample[-1], \(i) seq(ng) \%in\% i) )
pkern_plot(as.integer(idx_overlap), gdim, zlab='times sampled')

# plot each list element a different color
group_sample = rep(0L, prod(gdim))
for(i in seq(1 + interval^2)[-1]) group_sample[ idx_sample[[i]] ] = i-1L
pkern_plot(group_sample, gdim, breaks=c('not sampled', seq(interval^2)), zlab='sub-grid')

# compare with over=TRUE (usually results in overlap - try running a few times)
idx_sample_compare = pkern_sample_pt(gdim, n=n, interval=interval, lag_max=lag_max, over=TRUE)
idx_overlap_compare = rowSums( sapply(idx_sample_compare[-1], \(i) seq(ng) \%in\% i) )
pkern_plot(as.integer(idx_overlap_compare), gdim, zlab='times sampled')

# only non-NA points are eligible in initial sample of center points
g = pkern_grid(gdim)
g$gval = rep(NA, ng)
idx_obs = sample.int(ng, ng/1e2)
g$gval[idx_obs] = 'non-NA'
pkern_plot(g)

# draw a sample of center points and indicate sub-grids in color
idx_sample = pkern_sample_pt(g, n=10, lag_max=6L, interval=2)
g$gval[unlist(idx_sample[-1])] = 'sub-grid'
g$gval[idx_sample[[1]]] = 'center point'
pkern_plot(g)

}
