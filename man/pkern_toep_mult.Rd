% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pkern_var.R
\name{pkern_toep_mult}
\alias{pkern_toep_mult}
\title{Efficiently compute yzx for symmetric Toeplitz matrices y and x}
\usage{
pkern_toep_mult(y, z = NULL, x = NULL, idx_obs = NULL, gdim = NULL)
}
\arguments{
\item{y}{numeric matrix or vector, the symmetric Toeplitz matrix y or its first row/column}

\item{z}{numeric matrix or vector with dimensionality matching \code{y} (and 'x')}

\item{x}{numeric matrix or vector, the symmetric Toeplitz matrix x or its first row/column}
}
\value{
numeric matrix, the product of yzx or yz (if x is NULL)
}
\description{
This computes the product y \%*\% z (and, optionally, right-multiplies the result
by x) for symmetric Toeplitz matrices y (and x). It uses fast Fourier transforms to
reduce the memory footprint of computations, particularly when z is sparse.
}
\details{
By default z is set to the identity matrix, so that pkern_toep_mult(y) returns the
matrix y. For vector input y, it returns the Toeplitz matrix generated by y, similar
to \code{base::toeplitz}.

The function only requires the first row of y (and x). This is embedded in a
larger (zero-padded) vector representing a circulant matrix, whose action on a
zero-padded version of z is equivalent to element-wise product in Fourier space.
This allows the function to compute the desired matrix product without explicitly
forming y or x in memory.

The function is optimized for grid data z that are sparse (many zeros). Before
computing any transformations it first scans for and removes columns and rows of
z which are all zero (replacing them afterwards).
}
\examples{
# define example 1D exponential variogram
n = 10
y = exp(1-seq(n))
y_mat = pkern_toep_mult(y)
max( abs(y_mat - stats::toeplitz(y))  )

# multiply by random matrix and compare with default matrix multiply
z = matrix(rnorm(n^2), n)
result_default = y_mat \%*\% z
max( abs( result_default - pkern_toep_mult(y_mat, z) ) )

# save memory by passing only the first row of the Toeplitz matrix
max( abs( result_default - pkern_toep_mult(y, z) ) )

# sparsify z and repeat
idx_sparse = sample.int(n^2, n^2 - n)
z[idx_sparse] = 0
result_default = y_mat \%*\% z
max( abs( result_default - pkern_toep_mult(y, z) ) )

# right-multiply with another kernel
x = exp( 2 *( 1-seq(n) ) )
x_mat = pkern_toep_mult(x)
result_default = result_default \%*\% x_mat
max( abs( result_default - pkern_toep_mult(y, z, x) ) )

# z can also be supplied as vector of nonzero grid values
idx_obs = which(z != 0)
gdim = c(y=n, x=n)
max( abs( result_default - pkern_toep_mult(y, z=z[idx_obs], x, idx_obs, gdim) ) )

}
