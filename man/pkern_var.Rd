% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pkern_var.R
\name{pkern_var}
\alias{pkern_var}
\title{Compute covariance matrix for a (sub)sample of gridded data}
\usage{
pkern_var(
  g_obs,
  pars = NULL,
  scaled = FALSE,
  method = "none",
  X = NULL,
  fac = NULL,
  sep = TRUE
)
}
\arguments{
\item{g_obs}{list of form returned by \code{pkern_grid} (with entries 'gdim', 'gres', 'gval')}

\item{pars}{list of form returned by \code{pkern_pars} (with entries 'y', 'x', 'eps', 'psill')}

\item{scaled}{logical, if \code{TRUE} sets \code{pars$psill = 1} and \code{eps = pars$eps / pars$psill}}

\item{method}{character, the factorization to return, one of 'none', 'chol', 'eigen'}

\item{X}{numeric matrix, the \code{X} in \code{t(X) \%*\% V \%*\% X} (default is identity)}
}
\value{
either matrix \code{V}, or \code{t(X) \%*\% V_inv \%*\% X}, or a factorization ('chol' or 'eigen')
}
\description{
Computes the covariance matrix \code{V} for observed grid data \code{g_obs} and covariance model
\code{pars} (default \code{method=='none'}) or the quadratic form \code{t(X) \%*\% V_inv \%*\% X} where
\code{X} is a covariates matrix and \code{V_inv} is the inverse of \code{V}.
}
\details{
When \code{method=='eigen'} the function instead returns the eigen-decomposition of this
matrix; and when \code{method=='chol'} it returns the lower triangular Cholesky factor.

NAs in the data vector \code{g_obs$gval} indicate to return the marginal covariance, ie
the sub-matrix of V where the rows and columns corresponding to the NA grid points
are omitted. If \code{g_obs$gval} is a matrix, it is assumed to be an array of data vectors
(in the columns), all having NA structure identical to the first column.

The data vector(s) can be absent from \code{g_obs} (ie \code{is.null(g_obs$gval) == TRUE}),
in which case the function computes the full component correlation matrices (or their
factorization), for dimensions x and y, and returns them in a list (except when \code{X}
is supplied, since the output matrix is not generally separable in this case).

When \code{scaled=TRUE} and the data vector is supplied in \code{g_obs}, the function returns
\code{V/pars$psill} (or the appropriate sub-matrix, or factorization). If \code{X} is also supplied,
then the product \code{t(X) \%*\% V_inv \%*\% X} is scaled by this factor (but \code{V_inv} is computed
without the scaling).
}
\examples{
# define example grid with NAs and example predictors matrix
gdim = c(12, 13)
n = prod(gdim)
n_obs = floor(n/3)
idx_obs = sort(sample.int(n, n_obs))
g_obs = pkern_grid(gdim)
g_obs$gval[idx_obs] = rnorm(n_obs)
nX = 3
X_all = rnorm(nX * n) |> matrix(ncol=nX)

# example kernel
psill = 0.3
pars = pkern_pars(g_obs) |> modifyList(list(psill=psill))

# plot the full covariance matrix, its cholesky factor and eigen-decomposition
V = pkern_var(g_obs, pars)
V_chol = pkern_var(g_obs, pars, method='chol')
V_eigen = pkern_var(g_obs, pars, method='eigen')
pkern_plot(V)
pkern_plot(V_chol)
pkern_plot(V_eigen$vectors)

# with no NAs (or no data at all) the function returns the correlation matrix components
g_nodata = modifyList(g_obs, list(gval=NULL))
str(pkern_var(g_nodata, pars))
str(pkern_var(g_nodata, pars, method='chol'))
str(pkern_var(g_nodata, pars, method='eigen'))

# get the full covariance matrix with sep=FALSE...
V2 = pkern_var(g_nodata, pars, sep=FALSE)[idx_obs, idx_obs]
max(abs( V - V2 ))

# ... or compute it yourself from the components
corr_components = pkern_var(g_nodata, pars)
corr_mat = kronecker(corr_components[['x']], corr_components[['y']])
nugget_effect = diag(pars$eps, n)
V3 = pars$psill * corr_mat + nugget_effect
max(abs(V - V3[idx_obs, idx_obs]))

# test quadratic form with X
X = cbind(1, X_all)[idx_obs, ]
cprod = crossprod(X, chol2inv(chol(V))) \%*\% X
abs(max(pkern_var(g_obs, pars, X=X) - cprod ))

# test products with inverse of quadratic form with X
z = rnorm(nX + 1)
cprod_inv = chol2inv(chol(cprod))
pars0 = pars |> modifyList(list(psill=1, eps=0))
cprod_inv_chol = pkern_var(g_obs, pars, X=X, method='chol')
pkern_var_mult(z, pars0, fac=cprod_inv_chol) - (cprod_inv \%*\% z)

# `scaled` indicates to divide matrix by psill
print( pars[['eps']]/pars[['psill']] )
diag(pkern_var(g_obs, pars, scaled=TRUE)) # diagonal elements equal to 1 + eps/psill
( pkern_var(g_obs, pars) - psill * pkern_var(g_obs, pars, scaled=TRUE) ) |> abs() |> max()
( pkern_var(g_obs, pars, X=X, scaled=TRUE) - ( cprod/psill ) ) |> abs() |> max()

# in cholesky factor this produces a scaling by square root of psill
max(abs( V_chol - sqrt(psill) * pkern_var(g_obs, pars, method='chol', scaled=TRUE) ))
# and in the eigendecomposition, a scaling of the eigenvalues
vals_scaled = pkern_var(g_obs, pars, method='eigen', scaled=TRUE)$values
max(abs( pkern_var(g_obs, pars, method='eigen')$values - psill*vals_scaled ))

}
