% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pkern_variograms.R
\name{pkern_transform}
\alias{pkern_transform}
\title{Transform data forward and back}
\usage{
pkern_transform(x, nm = "nscore_smooth", log_offset = 1e-06)
}
\arguments{
\item{x, }{numeric data vector to transform (or list of them), or the output of pkern_transform}

\item{nm, }{the transformation name, one of 'linear', 'log', 'nscore', 'nscore_smooth'}

\item{log_offset, }{positive numeric, ignored if \code{nm} is not "log"}
}
\value{
list with: transformed data "z", transform name "nm", and back-transform function "bfun"
}
\description{
Apply a transformation to the data vector(s) in \code{x} and return the back-transform function.
}
\details{
\code{x} can be a numeric vector or a list of them. Data vector lists are handled in
\code{pken_transform} (and its returned \code{bfun} function) by applying the (back) transform to
each element using lapply, returning data as a list with the same structure as the input.

\code{x} can also be the return value of pkern_transform (a list with elements "z", "nm", "bfun"),
in which case the transform is applied to \code{x$z}, and the back-transform function is composed
appropriately with the previous one. This allows calls to pkern_transform to be chained
together (see examples).

Available functions (valid choices for \code{nm}) are:

"linear": applies \code{base::scale} with default options
"log": uses log(x + \code{log_offset})
"nscore": uses the normal score quantiles returned (in \code{y}) by \code{base::qqnorm}
"nscore_smooth": same as "nscore"

"nscore" and "nscore_smooth" differ in their method of constructing the back-transform;
The former uses linear interpolation (\code{stats::approx}) and the latter uses spline
interpolation (\code{stats::spline}).In both cases, the interpolators are constrained to
predict within the range of \code{x}, by padding their training data with extreme values from
both the transformed \code{x} input and the input \code{z} values. This implementation of "nscore"
is adapted from \code{mstats::backtr} and \code{mstats::nscore_model}.

\code{log_offset} is a small additive constant to ensure strict positivity of inputs to log().
It is ignored when \code{nm} is not "log".
}
\examples{

# generate large spread of random data
random_data = runif(-1e6, 1e6, n=1e3)

# log tranform:
transf_result = random_data |> pkern_transform('log')

# the function returns in a list:
z = transf_result$z # the transformed data
transf_result$nm |> print() # the transform name
bfun = transf_result$bfun # the back-transform function

# round trip accuracy is fine
(bfun(z) - random_data) |> abs() |> max()

# transform calls can be composed
transf_result = random_data |> pkern_transform('linear') |> pkern_transform('log') |> pkern_transform('linear')
print(transf_result$nm)
(transf_result$bfun(transf_result$z) - random_data) |> abs() |> max()

# both pkern_transform and its returned back-transform function are vectorized for lists
random_data = lapply(1:10, \(x) runif(-1e6, 1e6, n=1e3))
transf_result = random_data |> pkern_transform('linear') |> pkern_transform('log')
btrans_result = transf_result$bfun(transf_result$z)
str(btrans_result)
mapply(\(x, bx) max(abs(x-bx)), btrans_result, random_data) |> max()

}
