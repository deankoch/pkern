% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pkern_snap.R
\name{pkern_snap_score_2d}
\alias{pkern_snap_score_2d}
\title{2-d version of pkern_snap_score_1d (score function for optimizer in pkern_estimate_sep)}
\usage{
pkern_snap_score_2d(sep, g_target, pts, penalty = 1)
}
\arguments{
\item{sep}{integer vector of length 2, the sub-grid spacing indices}

\item{g_target}{list, the target grid configuration (see DETAILS)}

\item{pts}{list with named numeric vectors 'x', 'y', the point coordinates}

\item{penalty}{non-negative numeric, larger values penalize sparser grids}
}
\value{
numeric, the total squared snapping distance (plus penalty term)
}
\description{
Compute the total sum of squared snapping distances between the points in \code{pts} and
the grid lines of the sub-grid of \code{gl} with spacing \code{sep} (ie \code{sep-1} grid points lie
between adjacent sub-grid points) and offset \code{off} (ie the bottom left element of the
sub-grid is the \code{off}th x grid-line).
}
\details{
This function is minimized in order to select an appropriate sub-grid spacing when
snapping points to a high-resolution grid.

The tuning parameter \code{penalty>0} penalizes sparse grids with the aim of producing
simpler mappings and sub-grids of smaller dimension by adding a penalty term to the
squared distance sum equal to:

\code{penalty} X (number of unoccupied sub-grid points) X (mean squared distance)

set \code{penalty=0} to omit this term.

\code{g_target} should be a list containing named elements 'gdim', the grid dimensions,
and 'gyx', the grid line coordinates (as in the return value of pkern_fromRaster).
}
\examples{

# define a grid of coordinates and add jitter to a subgrid
gdim = c(y=300, x=300)
gres = c(y=2, x=2)
sep = c(y=15, x=18)
gyx = Map(\(p, r) seq(1, p, by=r), p=gdim, r=gres)
ng = prod(sapply(gyx, length))
pts = Map(\(p, r) seq(1, p, by=r), p=gdim, r=sep*gres) |>
 expand.grid() + stats::rnorm(2*ng, 0 , 2)
 # plot grid and the point set generated from it
 pkern_snap_plot(gyx, pts)

 # compute score for a range of x separation values
 sep_test = seq_along(gyx[['y']][-1])
 g = list(gyx=gyx, gdim=gdim, gres=gres)
 pts_list = pts |> as.data.frame() |> as.list()
 test_score = sapply(sep_test, \(y) pkern_snap_score_2d(sep=c(y=y, x=8), g, pts_list))
 plot(sep_test, test_score, pch=16, cex=0.5)
 lines(sep_test, test_score)
}
